// This file is part of emscripten-library-decorator,
// copyright (c) 2015-2016 BusFaster Ltd.
// Released under the MIT license, see LICENSE.
var evil;
/** Allow decorators to call eval() in the context that called them.
  * This is needed for various transformations.
  * @param otherEval must be this function: (code: string) => eval(code) */
function setEvil(otherEval) {
    evil = otherEval;
}
exports.setEvil = setEvil;
/** @dep decorator.
  * Apply to a function, to list other required variables needing protection
  * from dead code removal.
  * Arguments can be functions or names of global variables. */
function dep() {
    var depList = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        depList[_i] = arguments[_i];
    }
    return (function (target, functionName) {
        // Export names of other functions required by <functionName>
        // as an array named <functionName>__deps.
        var key = functionName + '__deps';
        var lib = target;
        lib[key] = (lib[key] || []).concat(depList.map(function (dep) {
            var name;
            if (typeof (dep) == 'function') {
                // Get name of required function and remove underscore prefix.
                name = dep.name.substr(1);
                // Export required function with prefix removed from its name.
                lib[name] = dep;
            }
            else {
                name = dep.substr(1);
                // Export any required global variable,
                // looking it up by name in current scope.
                if (name != 'initNamespaces')
                    lib[name] = evil('(' + dep + ')');
            }
            // Send name without prefix to __deps list.
            return (name);
        }));
    });
}
exports.dep = dep;
/** @exportLibrary decorator.
  * Apply to a class with static methods, to export them as functions. */
function exportLibrary(target) {
    mergeInto(LibraryManager.library, target);
}
exports.exportLibrary = exportLibrary;
var namespaceBodyTbl = {};
var namespaceDepTbl = {};
/** @prepareNamespace decorator.
  * Apply to an empty, named dummy class defined at the end of the namespace
  * block, to prepare its contents for export in an Emscripten library.
  * Namespaces with matching names in different files are merged together.
  * All code in the block is separated because Emscripten only outputs global
  * functions, not methods. */
function prepareNamespace(name) {
    var depList = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        depList[_i - 1] = arguments[_i];
    }
    return (function (target) {
        var body = evil('__decorate').caller.toString();
        var prefix = new RegExp('^[ (]*function *\\( *' + name + ' *\\) *\\{');
        var suffix = new RegExp('var +' + target.name + ' *= *[^]*$');
        body = (namespaceBodyTbl[name] || '') + body.replace(prefix, '').replace(suffix, '');
        namespaceBodyTbl[name] = body;
        if (!namespaceDepTbl[name])
            namespaceDepTbl[name] = {};
        for (var _i = 0, depList_1 = depList; _i < depList_1.length; _i++) {
            var dep_1 = depList_1[_i];
            namespaceDepTbl[name][dep_1.substr(1)] = evil('(' + dep_1 + ')');
        }
    });
}
exports.prepareNamespace = prepareNamespace;
/** Call once per namespace at the global level, after all files with contents
  * in that namespace have been imported. Clears the namespace and exports a
  * "postset" function to populate it using its original code. */
function publishNamespace(name) {
    var exportName = name.substr(1);
    var body = namespaceBodyTbl[name];
    var bodyWrapped = '(function(' + name + '){' + body + '})' + '(' + name + ')';
    evil(name + '={};');
    var lib = {
        _decorate: evil('__decorate'),
        _extends: evil('__extends'),
        defineHidden: defineHidden
    };
    for (var _i = 0, _a = Object.keys(namespaceDepTbl[name]); _i < _a.length; _i++) {
        var depName = _a[_i];
        lib[depName] = namespaceDepTbl[name][depName];
    }
    lib[exportName + '__deps'] = Object.keys(lib);
    lib[exportName + '__postset'] = bodyWrapped;
    mergeInto(LibraryManager.library, lib);
}
exports.publishNamespace = publishNamespace;
/** @_defineHidden decorator.
  * Assign to a local variable called _defineHidden before using.
  * Apply to a property to protect it from modifications and hide it. */
function defineHidden(value) {
    return (function (target, key) {
        Object.defineProperty(target, key, {
            configurable: false,
            enumerable: false,
            value: value,
            writable: true
        });
    });
}
exports.defineHidden = defineHidden;
