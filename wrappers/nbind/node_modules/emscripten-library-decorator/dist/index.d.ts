/** Allow decorators to call eval() in the context that called them.
  * This is needed for various transformations.
  * @param otherEval must be this function: (code: string) => eval(code) */
export declare function setEvil(otherEval: (code: string) => any): void;
/** @dep decorator.
  * Apply to a function, to list other required variables needing protection
  * from dead code removal.
  * Arguments can be functions or names of global variables. */
export declare function dep(...depList: (((...args: any[]) => any) | string)[]): (target: Object, functionName: string) => void;
/** @exportLibrary decorator.
  * Apply to a class with static methods, to export them as functions. */
export declare function exportLibrary(target: any): void;
/** @prepareNamespace decorator.
  * Apply to an empty, named dummy class defined at the end of the namespace
  * block, to prepare its contents for export in an Emscripten library.
  * Namespaces with matching names in different files are merged together.
  * All code in the block is separated because Emscripten only outputs global
  * functions, not methods. */
export declare function prepareNamespace(name: string, ...depList: string[]): (target: any) => void;
/** Call once per namespace at the global level, after all files with contents
  * in that namespace have been imported. Clears the namespace and exports a
  * "postset" function to populate it using its original code. */
export declare function publishNamespace(name: string): void;
/** @_defineHidden decorator.
  * Assign to a local variable called _defineHidden before using.
  * Apply to a property to protect it from modifications and hide it. */
export declare function defineHidden(value?: any): (target: Object, key: string) => void;
