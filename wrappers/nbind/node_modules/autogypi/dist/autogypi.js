// This file is part of autogypi, copyright (C) 2015-2016 BusFaster Ltd.
// Released under the MIT license, see LICENSE.
"use strict";
var fs = require('fs');
var path = require('path');
var Promise = require('bluebird');
var resolve = require('resolve');
/** Save pretty-printed JSON object to a file. */
function writeJson(outputPath, json, name, header) {
    var writeFile = Promise.promisify(fs.writeFile);
    return (writeFile(outputPath, ((header || '') +
        JSON.stringify(json, null, 1).replace(/\n +/g, function (indent) { return indent.replace(/ /g, '\t'); }) +
        '\n'), { encoding: 'utf-8' }));
}
exports.writeJson = writeJson;
function parseConfig(configPath, config) {
    var basePath = path.dirname(configPath);
    if (!config) {
        try {
            config = require(configPath);
        }
        catch (err) {
            return (Promise.reject(err));
        }
    }
    function resolveFile(relativePath) {
        return (path.resolve(basePath, relativePath));
    }
    // Get list of gypi options for required Node.js modules.
    var dependenciesDone = Promise.map(config.dependencies || [], function (dep) {
        // Find package.json file of required module.
        return Promise.promisify(resolve)(dep, {
            basedir: basePath,
            packageFilter: function (json) {
                json.main = 'package.json';
                return (json);
            }
        }).then(function (entry) {
            // Parse possible autogypi.json file specifying how to include the module.
            return parseConfig(path.resolve(path.dirname(entry), 'autogypi.json')).catch(function (err) {
                // No configuration file found, just add the root directory to include paths.
                // This is enough for nan.
                var pair = {
                    gypi: {
                        'include_dirs': [path.dirname(entry)]
                    }
                };
                return (pair);
            });
        });
    });
    var parseDone = dependenciesDone.then(function (gypiList) {
        var gypi = {};
        var gypiTop = {};
        // Flatten list of gypi options for required modules,
        // concatenating all lists of files with matching keys.
        for (var _i = 0, gypiList_1 = gypiList; _i < gypiList_1.length; _i++) {
            var sub = gypiList_1[_i];
            for (var _a = 0, _b = Object.keys(sub.gypi || {}); _a < _b.length; _a++) {
                var key = _b[_a];
                gypi[key] = (gypi[key] || []).concat(sub.gypi[key]);
            }
            for (var _c = 0, _d = Object.keys(sub.gypiTop || {}); _c < _d.length; _c++) {
                var key = _d[_c];
                gypiTop[key] = (gypiTop[key] || []).concat(sub.gypiTop[key]);
            }
        }
        // Add options for this module. Make all paths absolute.
        if (config.includes) {
            gypi.includes = (gypi.includes || []).concat(config.includes.map(resolveFile));
        }
        if (config.topIncludes) {
            gypiTop.includes = (gypiTop.includes || []).concat(config.topIncludes.map(resolveFile));
        }
        var pair = {
            gypi: gypi,
            gypiTop: gypiTop
        };
        return (pair);
    });
    return (parseDone);
}
function relativize(outputPath, gypi) {
    function relativizeList(pathList) {
        return (pathList.map(function (absolutePath) {
            return path.relative(outputPath, absolutePath);
        }));
    }
    for (var _i = 0, _a = ['include_dirs', 'includes']; _i < _a.length; _i++) {
        var key = _a[_i];
        if (gypi[key])
            gypi[key] = relativizeList(gypi[key]);
    }
}
/** Write auto.gypi and auto-top.gypi files according to config.
  * @param config Contents of autogypi.json. */
function generate(opts, config) {
    var parseDone = parseConfig(opts.configPath, config);
    var generateDone = parseDone.then(function (result) {
        var header = [
            '# Automatically generated file. Edits will be lost.',
            '# Based on: ' + path.relative(path.dirname(opts.outputPath), opts.configPath),
            '', ''
        ].join('\n');
        // Serialize generated .gypi contents with relative paths to output JSON files.
        relativize(path.dirname(opts.outputPath), result.gypi);
        var writeTasks = [
            writeJson(opts.outputPath, result.gypi, 'gypi', header)
        ];
        if (opts.outputTopPath) {
            relativize(path.dirname(opts.outputTopPath), result.gypiTop);
            writeTasks.push(writeJson(opts.outputTopPath, result.gypiTop, 'gypi', header));
        }
        return (Promise.all(writeTasks));
    });
    return (generateDone);
}
exports.generate = generate;
/** Return an object with contents for an initial binding.gyp file. */
function initGyp(opts) {
    var basePath = opts.basePath;
    var gyp = {
        targets: [
            {
                includes: [
                    path.relative(basePath, opts.outputPath)
                ],
                sources: opts.sourceList.map(function (src) { return path.relative(basePath, src); })
            }
        ]
    };
    if (opts.outputTopPath) {
        gyp.includes = [
            path.relative(basePath, opts.outputTopPath)
        ];
    }
    return (gyp);
}
exports.initGyp = initGyp;
