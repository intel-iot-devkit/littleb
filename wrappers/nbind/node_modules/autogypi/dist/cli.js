// This file is part of autogypi, copyright (C) 2015-2016 BusFaster Ltd.
// Released under the MIT license, see LICENSE.
"use strict";
var path = require('path');
var cmd = require('commander');
var autogypi_1 = require('./autogypi');
function parseBool(flag) {
    var falseTbl = {
        '0': true,
        'no': true,
        'false': true
    };
    return (!flag || !falseTbl[flag.toLowerCase()]);
}
function push(item, list) {
    list.push(item);
    return (list);
}
/* tslint:disable:max-line-length */
(cmd.version(require('../package.json').version)
    .description('Generate node-gyp dependency files.')
    .option('-r, --root <path>', 'root path for config files, default is shell working directory')
    .option('-c, --config <path>', 'config file, default autogypi.json')
    .option('-o, --output <path>', 'per-target gypi file to create, default auto.gypi')
    .option('-t, --output-top <path>', 'top-level gypi file to create, default auto-top.gypi')
    .option('-T, --no-output-top', 'omit top-level gypi file')
    .option('-p, --package <path>', 'add dependency on another npm package', push, [])
    .option('-I, --include-dir <path>', 'add include directory for header files', push, [])
    .option('--save [flag]', 'save changes to config file', parseBool)
    .option('--init-gyp [path]', 'create gyp file (default binding.gyp, implies --save) with options:', parseBool)
    .option('-s, --source <path>', '  - add C or C++ source file', push, [])
    .action(handleGenerate)
    .parse(process.argv));
/* tslint:enable:max-line-length */
handleGenerate(cmd.opts());
/** Return sorted unique values from multiple arrays. */
function concatUnique() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    var tbl = {};
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
        var list = args_1[_a];
        for (var _b = 0, _c = list || []; _b < _c.length; _b++) {
            var item = _c[_b];
            tbl[item] = true;
        }
    }
    return (Object.keys(tbl).sort());
}
function handleGenerate(opts) {
    var cwd = process.cwd();
    var root = opts['root'] || cwd;
    function resolve(pathName, pathDefault) {
        if (typeof (pathName) == 'string') {
            return (path.resolve(cwd, pathName));
        }
        else if (pathDefault) {
            return (path.resolve(root, pathDefault));
        }
        else {
            return (null);
        }
    }
    var configPath = resolve(opts['config'], 'autogypi.json');
    var gypPath;
    if (opts['initGyp'])
        gypPath = resolve(opts['initGyp'], 'binding.gyp');
    if (!opts['root']) {
        var refPath = configPath || gypPath;
        if (refPath)
            root = path.dirname(refPath);
    }
    var outputPath = resolve(opts['output'], 'auto.gypi');
    var outputTopPath = resolve(opts['outputTop'], 'auto-top.gypi');
    var config;
    try {
        config = require(configPath);
    }
    catch (err) {
        config = {};
    }
    if (opts['output']) {
        config.output = path.relative(path.dirname(configPath), outputPath);
    }
    else {
        outputPath = path.resolve(path.dirname(configPath), config['output'] || outputPath);
    }
    if (typeof (opts['outputTop']) == 'string') {
        config.outputTop = path.relative(path.dirname(configPath), outputTopPath);
    }
    else {
        outputTopPath = path.resolve(path.dirname(configPath), config['outputTop'] || outputTopPath);
    }
    config['dependencies'] = concatUnique(config.dependencies, opts['package']);
    config['includes'] = concatUnique(config.includes, opts['includeDir']);
    if (opts['save'] || opts['initGyp'])
        autogypi_1.writeJson(configPath, config, 'config');
    if (opts['outputTop'] === false)
        outputTopPath = null;
    if (opts['initGyp']) {
        gypPath = resolve(opts['initGyp'], 'binding.gyp');
        var gyp = autogypi_1.initGyp({
            basePath: path.dirname(gypPath),
            outputPath: outputPath,
            outputTopPath: outputTopPath,
            sourceList: opts['source'].map(function (src) { return path.resolve(cwd, src); })
        });
        autogypi_1.writeJson(gypPath, gyp, 'gyp template');
    }
    var generateOptions = {
        configPath: configPath,
        outputPath: outputPath,
        outputTopPath: outputTopPath
    };
    autogypi_1.generate(generateOptions, config).catch(function (err) {
        console.error('Error: could not generate gypi files:');
        console.error(err);
    });
}
